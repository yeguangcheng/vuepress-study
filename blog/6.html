<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.36">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/img/favicon.ico"><title>高级前端进修之路</title><meta name="description" content="高级前端进修之路">
    <link rel="modulepreload" href="/vuepress-study/assets/app.b87228d2.js"><link rel="modulepreload" href="/vuepress-study/assets/6.html.9d6c3c6b.js"><link rel="modulepreload" href="/vuepress-study/assets/6.html.e98206aa.js"><link rel="modulepreload" href="/vuepress-study/assets/plugin-vue_export-helper.21dcd24c.js">
    <link rel="stylesheet" href="/vuepress-study/assets/style.b6b1af50.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container no-sidebar"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/vuepress-study/" class=""><img class="logo" src="/vuepress-study/img/logo.png" alt="高级前端进修之路"><span class="site-name can-hide">高级前端进修之路</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/vuepress-study/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-study/line" class="" aria-label="学习路线"><!--[--><!--]--> 学习路线 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-study/blog" class="router-link-active" aria-label="技术文章"><!--[--><!--]--> 技术文章 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-study/subject/js/1" class="" aria-label="面试题汇总"><!--[--><!--]--> 面试题汇总 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/vuepress-study/" class="" aria-label="Home"><!--[--><!--]--> Home <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-study/line" class="" aria-label="学习路线"><!--[--><!--]--> 学习路线 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-study/blog" class="router-link-active" aria-label="技术文章"><!--[--><!--]--> 技术文章 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/vuepress-study/subject/js/1" class="" aria-label="面试题汇总"><!--[--><!--]--> 面试题汇总 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><!----><!--[--><!--]--></aside><!--]--><!--[--><div class="page"><div class="content"><!--[--><h2 id="面试官-说说作用域和闭包吧" tabindex="-1"><a class="header-anchor" href="#面试官-说说作用域和闭包吧" aria-hidden="true">#</a> 面试官：说说作用域和闭包吧</h2><blockquote><p>几乎所有语言的最基础模型之一就是在变量中存储值，并且在稍后取出或修改这些值。在变量中存储值和取出值的能力，给程序赋予了状态。这就引伸出两个问题：这些变量被存储在哪里？程序如何在需要的时候找到它们？回答这些问题需要一组明确定义的规则，它定义了如何存储变量，以及如何找到这些变量。我们称这组规则为：作用域。</p></blockquote><h2 id="lhs-和-rhs-查询" tabindex="-1"><a class="header-anchor" href="#lhs-和-rhs-查询" aria-hidden="true">#</a> LHS 和 RHS 查询</h2><blockquote><p>在说 javascript 中的作用域之前，我想应该先了解一下 LHS 和 RHS 查询，这对于作用域的理解有所帮助。</p></blockquote><p>虽然 <code>javascript</code> 被认为是一门解释型语言/动态语言，但是它其实是一种编译型的语言。一般来说，需要运行一段 <code>javascript</code> 代码，有两个必不可少的东西：<strong>JS 引擎</strong> 和 <strong>编译器</strong>。前者类似于总管的角色，负责整个程序运行时所需的各种资源的调度；后者只是前者的一部分，负责将 <code>javascript</code> 源码编译成机器能识别的机器指令，然后交给引擎运行。</p><h3 id="编译" tabindex="-1"><a class="header-anchor" href="#编译" aria-hidden="true">#</a> 编译</h3><p>在 <code>javascript</code> 中，一段源码在被执行之前大概会经历以下三个步骤，这也被称之为 <strong>编译</strong>：</p><ol><li><strong>分词 / 词法分析</strong>：编译器会先将一连串字符打断成（对于语言来说）有意义的片段，称为 token（记号），例如 <code>var a = 2;</code>。这段程序很可能会被打断成如下 token：<code>var</code>，<code>a</code>，<code>=</code>，<code>2</code>，和 <code>;</code>。</li><li><strong>解析 / 语法分析</strong>：编译器将一个 <code>token</code> 的流（数组）转换为一个“抽象语法树”（<code>AST —— Abstract Syntax Tree</code>），它表示了程序的语法结构。</li><li><strong>代码生成</strong>：编译器将上一步中生成的抽象语法树转换为机器指令，等待引擎执行。</li></ol><h3 id="执行" tabindex="-1"><a class="header-anchor" href="#执行" aria-hidden="true">#</a> 执行</h3><p>编译器一顿操作猛如虎，生成了一堆机器指令，JS 引擎开心地拿到这堆指令，开始执行，这个时候我们要说的 <code>LHS</code> 和 <code>RHS</code> 就登场了。</p><p><code>LHS (Left-hand Side)</code> 和 <code>RHS (Right-hand Side)</code> ，是在代码执行阶段 JS 引擎操作变量的两种方式，二者区别就是对变量的查询目的是 <strong>变量赋值</strong> 还是 <strong>查询</strong> 。</p><p><strong><code>LHS</code></strong> 可以理解为变量在赋值操作符<code>(=)</code>的左侧，例如 <code>a = 1</code>，当前引擎对变量 <code>a</code> 查找的目的是<strong>变量赋值</strong>。这种情况下，引擎不关心变量 <code>a</code> 原始值是什么，只管将值 <code>1</code> 赋给 <code>a</code> 变量。</p><p><strong><code>RHS</code></strong> 可以理解为变量在赋值操作符<code>(=)</code>的右侧，例如：<code>console.log(a)</code>，其中引擎对变量<code>a</code>的查找目的就是 <strong>查询</strong>，它需要找到变量 <code>a</code> 对应的实际值是什么，然后才能将它打印出来。</p><p>来看下面这段代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// LHS 查询</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>这段代码运行时，引擎做了一个 <code>LHS</code> 查询，找到 <code>a</code> ，并把新值 <code>2</code> 赋给它。再看下面一段：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// LHS 查询</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// RHS 查询</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// RHS 查询</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>为了执行它，JS 引擎既做了 <code>LHS</code> 查询又做了 <code>RHS</code> 查询，只不过这里的 <code>LHS</code> 比较难发现。</p><p>总之，引擎想对变量进行获取 / 赋值，就离不开 <code>LHS</code> 和 <code>RHS</code> ，然而这两个操作只是手段，到哪里去获取变量才是关键。<code>LHS</code> 和 <code>RHS</code> 获取变量的位置就是 <strong>作用域</strong>。</p><h2 id="什么是作用域" tabindex="-1"><a class="header-anchor" href="#什么是作用域" aria-hidden="true">#</a> 什么是作用域</h2><blockquote><p>简单来说，<strong>作用域</strong> 指程序中定义变量的区域，它决定了当前执行代码对变量的访问权限。</p></blockquote><p><code>javascript</code> 中大部分情况下，只有两种作用域类型：</p><ul><li><strong>全局作用域</strong>：全局作用域为程序的最外层作用域，一直存在。</li><li><strong>函数作用域</strong>：函数作用域只有函数被定义时才会创建，包含在父级函数作用域 / 全局作用域内。</li></ul><blockquote><p>由于作用域的限制，每段独立的执行代码块只能访问自己作用域和外层作用域中的变量，无法访问到内层作用域的变量。</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">/* 全局作用域开始 */</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>

<span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* func 函数作用域开始 */</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token comment">/* func 函数作用域结束 */</span>

<span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; 2</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// =&gt; 1</span>

<span class="token comment">/* 全局作用域结束 */</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><h2 id="作用域链" tabindex="-1"><a class="header-anchor" href="#作用域链" aria-hidden="true">#</a> 作用域链</h2><p>上面代码示范中，可执行代码块是能够在自己的作用域中找到变量的，那么如果在自己的作用域中找不到目标变量，程序能否正常运行？来看下面的代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> b <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">2</span>

    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token function">bar</span><span class="token punctuation">(</span>b <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 2 4 12</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>结合前面的知识我们知道，在 <code>bar</code> 函数内部，会做三次 <code>RHS</code> 查询从而分别获取到 <code>a</code> <code>b</code> <code>c</code> 三个变量的值。<code>bar</code> 内部作用域中只能获取到变量 <code>c</code> 的值，<code>a</code> 和 <code>b</code> 都是从外部 <code>foo</code> 函数的作用域中获取到的。</p><blockquote><p>当可执行代码内部访问变量时，会先查找本地作用域，如果找到目标变量即返回，否则会去父级作用域继续查找...一直找到全局作用域。我们把这种作用域的嵌套机制，称为 作用域链。</p></blockquote><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/22/1723a816c2f59e4f~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><p>用图片表示，上述代码一共有三层作用域嵌套，分别是：</p><ol><li>全局作用域</li><li><code>foo</code> 作用域</li><li><code>bar</code> 作用域</li></ol><blockquote><p>需要注意，函数参数也在函数作用域中。</p></blockquote><h2 id="词法作用域" tabindex="-1"><a class="header-anchor" href="#词法作用域" aria-hidden="true">#</a> 词法作用域</h2><p>明白了作用域和作用域链的概念，我们来看词法作用域。</p><p><strong>词法作用域</strong>（<code>Lexical Scopes</code>）是 <code>javascript</code> 中使用的作用域类型，<strong>词法作用域</strong> 也可以被叫做 <strong>静态作用域</strong>，与之相对的还有 <strong>动态作用域</strong>。那么 <code>javascript</code> 使用的 <strong>词法作用域</strong> 和 <strong>动态作用域</strong> 的区别是什么呢？看下面这段代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">1</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 结果是 ???</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>上面这段代码中，一共有三个作用域：</p><ul><li>全局作用域</li><li><code>foo</code> 的函数作用域</li><li><code>bar</code> 的函数作用域</li></ul><p>一直到这边都好理解，可是 <code>foo</code> 里访问了本地作用域中没有的变量 <code>value</code> 。根据前面说的，引擎为了拿到这个变量就要去 <code>foo</code> 的上层作用域查询，那么 <code>foo</code> 的上层作用域是什么呢？是它 <strong>调用时</strong> 所在的 bar 作用域？还是它 <strong>定义时</strong> 所在的全局作用域？</p><p>这个关键的问题就是 <code>javascript</code> 中的作用域类型——<strong>词法作用域。</strong></p><blockquote><p>词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。</p></blockquote><p>如果是动态作用域类型，那么上面的代码运行结果应该是 <code>bar</code> 作用域中的 <code>2</code> 。也许你会好奇什么语言是动态作用域？<code>bash</code> 就是动态作用域，感兴趣的小伙伴可以了解一下。</p><h2 id="块级作用域" tabindex="-1"><a class="header-anchor" href="#块级作用域" aria-hidden="true">#</a> 块级作用域</h2><p>什么是块级作用域呢？简单来说，花括号内 <code>{...}</code> 的区域就是块级作用域区域。</p><p>很多语言本身都是支持块级作用域的。上面我们说，<code>javascript</code> 中大部分情况下，只有两种作用域类型：<strong>全局作用域</strong> 和 <strong>函数作用域</strong>，那么 <code>javascript</code> 中有没有块级作用域呢？来看下面的代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 结果???</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>运行后会发现，结果还是 <code>1</code>，花括号内定义并赋值的 a 变量跑到全局了。这足以说明，<code>javascript</code> 不是原生支持块级作用域的，起码创作者创造这门语言的时候压根就没把块级作用域的事情考虑进去...（出来背锅！！）</p><p>但是 <code>ES6</code> 标准提出了使用 <code>let</code> 和 <code>const</code> 代替 <code>var</code> 关键字，来“创建块级作用域”。也就是说，上述代码改成如下方式，块级作用域是有效的：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// ReferenceError</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><blockquote><p>关于 <code>let</code> 和 <code>const</code> 的更多细节，进入 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fmitianyi.gitbook.io%2Ffrontend-interview-guide%2Fes6%2Flet-and-const" title="https://mitianyi.gitbook.io/frontend-interview-guide/es6/let-and-const" target="_blank" rel="noopener noreferrer">传送门<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a></p></blockquote><h2 id="创建作用域" tabindex="-1"><a class="header-anchor" href="#创建作用域" aria-hidden="true">#</a> 创建作用域</h2><p>在 <code>javascript</code> 中，我们有几种创建 / 改变作用域的手段：</p><ol><li><p>定义函数，创建函数作用（推荐）：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 创建了一个 foo 的函数作用域</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li><li><p>使用 <code>let</code> 和 <code>const</code> 创建块级作用域（推荐）：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// ReferenceError</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li><li><p><code>try catch</code> 创建作用域（不推荐）,<code>err</code> 仅存在于 <code>catch</code> 子句中：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">undefined</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 强制产生异常</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token comment">// TypeError: undefined is not a function</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token comment">// ReferenceError: `err` not found</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><p>使用 <code>eval</code> “欺骗” 词法作用域（不推荐）：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">str<span class="token punctuation">,</span> a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">eval</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token string">&#39;var b = 3;&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 1 3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li><li><p>使用 <code>with</code> 欺骗词法作用域（不推荐）：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">with</span> <span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        a <span class="token operator">=</span> <span class="token number">2</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">a</span><span class="token operator">:</span> <span class="token number">3</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">b</span><span class="token operator">:</span> <span class="token number">3</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o1<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// 2</span>

<span class="token function">foo</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>o2<span class="token punctuation">.</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 2 -- 全局作用域被泄漏了！</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div></li></ol><blockquote><p>总结下来，能够使用的创建作用域的方式就两种：定义函数创建 和 let const 创建。</p></blockquote><h2 id="作用域的应用场景" tabindex="-1"><a class="header-anchor" href="#作用域的应用场景" aria-hidden="true">#</a> 作用域的应用场景</h2><p>作用域的一个常见运用场景之一，就是 <strong>模块化</strong>。</p><blockquote><p>由于 javascript 并未原生支持模块化导致了很多令人口吐芬芳的问题，比如全局作用域污染和变量名冲突，代码结构臃肿且复用性不高。在正式的模块化方案出台之前，开发者为了解决这类问题，想到了使用函数作用域来创建模块的方案。</p></blockquote><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">module1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">module2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">module1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; 1</span>
<span class="token function">module2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; 2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>上面的代码中，构建了 <code>module1</code> 和 <code>module2</code> 两个代表模块的函数，两个函数内分别定义了一个同名变量 <code>a</code> ，由于函数作用域的隔离性质，这两个变量被保存在不同的作用域中（不嵌套），JS 引擎在执行这两个函数时会去不同的作用域中读取，并且外部作用域无法访问到函数内部的 <code>a</code> 变量。这样一来就巧妙地解决了 <strong>全局作用域污染</strong> 和 <strong>变量名冲突</strong> 的问题；并且，由于函数的包裹写法，这种方式看起来封装性好多了。</p><p>然而上面的函数声明式写法，看起来还是有些冗余，更重要的是，<code>module1</code> 和 <code>module2</code> 的函数名本身就已经对全局作用域造成了污染。我们来继续改写：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// module1.js</span>
<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// module2.js</span>
<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>将函数声明改写成 <strong>立即调用函数表达式（<code>Immediately Invoked Function Expression</code> 简写 <code>IIFE</code></strong>），封装性更好，代码也更简洁，解决了模块名污染全局作用域的问题。</p><blockquote><p>函数声明和函数表达式，最简单的区分方法，就是看是不是 function 关键字开头：是 function 开头的就是函数声明，否则就是函数表达式。</p></blockquote><p>上面的代码采用了 <code>IIFE</code> 的写法，已经进化很多了，我们可以再把它强化一下，强化成后浪版，赋予它判断外部环境的权利——<strong>选择的权力</strong>。</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">global</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>global<span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// is browser</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>global<span class="token operator">...</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// is nodejs</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>让后浪继续奔涌，我们的想象力不足以想象 <code>UMD</code> 模块化的代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// UMD 模块化</span>
<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> factory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> define <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span> <span class="token operator">&amp;&amp;</span> define<span class="token punctuation">.</span>amd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// AMD</span>
        <span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;jquery&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span> factory<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> exports <span class="token operator">===</span> <span class="token string">&#39;object&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Node, CommonJS-like</span>
        module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;jquery&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// Browser globals (root is window)</span>
        root<span class="token punctuation">.</span>returnExports <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>jQuery<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">$</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// methods</span>
    <span class="token keyword">function</span> <span class="token function">myFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

    <span class="token comment">// exposed public method</span>
    <span class="token keyword">return</span> myFunc
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>我看着作用域的模块化应用场景，真的是满怀羡慕。如果你也和我一样羡慕并且，想了解更多关于模块化的东西，请进入 <a href="https://link.juejin.cn/?target=https%3A%2F%2Fmitianyi.gitbook.io%2Ffrontend-interview-guide%2Fjavascript-basics%2Fmodularization" title="https://mitianyi.gitbook.io/frontend-interview-guide/javascript-basics/modularization" target="_blank" rel="noopener noreferrer">传送门<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>。</p><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包" aria-hidden="true">#</a> 闭包</h2><p>说完了作用域，我们来说说 <strong>闭包</strong>。</p><blockquote><p>能够访问其他函数内部变量的函数，被称为 <strong>闭包</strong>。</p></blockquote><p>上面这个定义比较难理解，简单来说，<strong>闭包就是函数内部定义的函数，被返回了出去并在外部调用</strong>。我们可以用代码来表述一下：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>

    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> bar
<span class="token punctuation">}</span>

<span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 这就形成了一个闭包</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>我们可以简单剖析一下上面代码的运行流程：</p><ol><li>编译阶段，变量和函数被声明，作用域即被确定。</li><li>运行函数 <code>foo()</code>，此时会创建一个 <code>foo</code> 函数的执行上下文，执行上下文内部存储了 <code>foo</code> 中声明的所有变量函数信息。</li><li>函数 <code>foo</code> 运行完毕，将内部函数 <code>bar</code> 的引用赋值给外部的变量 <code>baz</code> ，此时 <code>baz</code> 指针指向的还是 <code>bar</code> ，因此哪怕它位于 <code>foo</code> 作用域之外，它还是能够获取到 <code>foo</code> 的内部变量。</li><li><code>baz</code> 在外部被执行，<code>baz</code> 的内部可执行代码 <code>console.log</code> 向作用域请求获取 <code>a</code> 变量，本地作用域没有找到，继续请求父级作用域，找到了 <code>foo</code> 中的 <code>a</code> 变量，返回给 <code>console.log</code>，打印出 <code>2</code>。</li></ol><p>闭包的执行看起来像是开发者使用的一个小小的 “作弊手段” ——<strong>绕过了作用域的监管机制，从外部也能获取到内部作用域的信息</strong>。闭包的这一特性极大地丰富了开发人员的编码方式，也提供了很多有效的运用场景。</p><h2 id="闭包的应用场景" tabindex="-1"><a class="header-anchor" href="#闭包的应用场景" aria-hidden="true">#</a> 闭包的应用场景</h2><blockquote><p>闭包的应用，大多数是在需要维护内部变量的场景下。</p></blockquote><h3 id="单例模式" tabindex="-1"><a class="header-anchor" href="#单例模式" aria-hidden="true">#</a> 单例模式</h3><p>单例模式是一种常见的涉及模式，它保证了一个类只有一个实例。实现方法一般是先判断实例是否存在，如果存在就直接返回，否则就创建了再返回。单例模式的好处就是避免了重复实例化带来的内存开销：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 单例模式</span>
<span class="token keyword">function</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> <span class="token string">&#39;singleton&#39;</span>
<span class="token punctuation">}</span>

Singleton<span class="token punctuation">.</span>getInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> instance

    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> instance
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> instance
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> sa <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> sb <span class="token operator">=</span> Singleton<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sa <span class="token operator">===</span> sb<span class="token punctuation">)</span> <span class="token comment">// true</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sa<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token comment">// &#39;singleton&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div><h3 id="模拟私有属性" tabindex="-1"><a class="header-anchor" href="#模拟私有属性" aria-hidden="true">#</a> 模拟私有属性</h3><p><code>javascript</code> 没有 <code>java</code> 中那种 <code>public</code> <code>private</code> 的访问权限控制，对象中的所用方法和属性均可以访问，这就造成了安全隐患，内部的属性任何开发者都可以随意修改。虽然语言层面不支持私有属性的创建，但是我们可以用闭包的手段来模拟出私有属性：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 模拟私有属性</span>
<span class="token keyword">function</span> <span class="token function">getGeneratorFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> _name <span class="token operator">=</span> <span class="token string">&#39;John&#39;</span>
    <span class="token keyword">var</span> _age <span class="token operator">=</span> <span class="token number">22</span>

    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span>
            <span class="token function-variable function">getName</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> _name
            <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token function-variable function">getAge</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> _age
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token function">getGeneratorFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
obj<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// John</span>
obj<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 22</span>
obj<span class="token punctuation">.</span>_age <span class="token comment">// undefined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h3 id="柯里化" tabindex="-1"><a class="header-anchor" href="#柯里化" aria-hidden="true">#</a> 柯里化</h3><blockquote><p>柯里化（<code>currying</code>），是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p></blockquote><p>这个概念有点抽象，实际上柯里化是高阶函数的一个用法，<code>javascript</code> 中常见的 <code>bind</code> 方法就可以用柯里化的方法来实现：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">myBind</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">context <span class="token operator">=</span> window</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span> <span class="token operator">!==</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&#39;Error&#39;</span><span class="token punctuation">)</span>
    <span class="token keyword">let</span> selfFunc <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token keyword">let</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 因为返回了一个函数，可以 new F()，所以需要判断</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">F</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">selfFunc</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// bind 可以实现类似这样的代码 f.bind(obj, 1)(2)，所以需要将两边的参数拼接起来</span>
            <span class="token keyword">return</span> <span class="token function">selfFunc</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>柯里化的优势之一就是 <strong>参数的复用</strong>，它可以在传入参数的基础上生成另一个全新的函数，来看下面这个类型判断函数：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">typeOf</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> toString <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString
        <span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token punctuation">{</span>
            <span class="token string-property property">&#39;[object Boolean]&#39;</span><span class="token operator">:</span> <span class="token string">&#39;boolean&#39;</span><span class="token punctuation">,</span>
            <span class="token string-property property">&#39;[object Number]&#39;</span><span class="token operator">:</span> <span class="token string">&#39;number&#39;</span><span class="token punctuation">,</span>
            <span class="token string-property property">&#39;[object String]&#39;</span><span class="token operator">:</span> <span class="token string">&#39;string&#39;</span><span class="token punctuation">,</span>
            <span class="token string-property property">&#39;[object Function]&#39;</span><span class="token operator">:</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">,</span>
            <span class="token string-property property">&#39;[object Array]&#39;</span><span class="token operator">:</span> <span class="token string">&#39;array&#39;</span><span class="token punctuation">,</span>
            <span class="token string-property property">&#39;[object Date]&#39;</span><span class="token operator">:</span> <span class="token string">&#39;date&#39;</span><span class="token punctuation">,</span>
            <span class="token string-property property">&#39;[object RegExp]&#39;</span><span class="token operator">:</span> <span class="token string">&#39;regExp&#39;</span><span class="token punctuation">,</span>
            <span class="token string-property property">&#39;[object Undefined]&#39;</span><span class="token operator">:</span> <span class="token string">&#39;undefined&#39;</span><span class="token punctuation">,</span>
            <span class="token string-property property">&#39;[object Null]&#39;</span><span class="token operator">:</span> <span class="token string">&#39;null&#39;</span><span class="token punctuation">,</span>
            <span class="token string-property property">&#39;[object Object]&#39;</span><span class="token operator">:</span> <span class="token string">&#39;object&#39;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> map<span class="token punctuation">[</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">===</span> value
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> isNumber <span class="token operator">=</span> <span class="token function">typeOf</span><span class="token punctuation">(</span><span class="token string">&#39;number&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> isFunction <span class="token operator">=</span> <span class="token function">typeOf</span><span class="token punctuation">(</span><span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> isRegExp <span class="token operator">=</span> <span class="token function">typeOf</span><span class="token punctuation">(</span><span class="token string">&#39;regExp&#39;</span><span class="token punctuation">)</span>

<span class="token function">isNumber</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; true</span>
<span class="token function">isFunction</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// true</span>
<span class="token function">isRegExp</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// =&gt; false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>通过向 <code>typeOf</code> 里传入不同的类型字符串参数，就可以生成对应的类型判断函数，作为语法糖在业务代码里重复使用。</p><h2 id="闭包的问题" tabindex="-1"><a class="header-anchor" href="#闭包的问题" aria-hidden="true">#</a> 闭包的问题</h2><p>从上面的介绍中我们可以得知，闭包的使用场景非常广泛，那我们是不是可以大量使用闭包呢？不可以，因为闭包过度使用会导致性能问题，还是看之前演示的一段代码：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span>

    <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> bar
<span class="token punctuation">}</span>

<span class="token keyword">var</span> baz <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 这就形成了一个闭包</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>乍一看，好像没什么问题，然而，它却有可能导致 <strong>内存泄露</strong>。</p><p>我们知道，<code>javascript</code> 内部的垃圾回收机制用的是引用计数收集：即当内存中的一个变量被引用一次，计数就加一。垃圾回收机制会以固定的时间轮询这些变量，将计数为 <code>0</code> 的变量标记为失效变量并将之清除从而释放内存。</p><p>上述代码中，理论上来说， <code>foo</code> 函数作用域隔绝了外部环境，所有变量引用都在函数内部完成，<code>foo</code> 运行完成以后，内部的变量就应该被销毁，内存被回收。然而闭包导致了全局作用域始终存在一个 <code>baz</code> 的变量在引用着 <code>foo</code> 内部的 <code>bar</code> 函数，这就意味着 <code>foo</code> 内部定义的 <code>bar</code> 函数引用数始终为 <code>1</code>，垃圾运行机制就无法把它销毁。更糟糕的是，<code>bar</code> 有可能还要使用到父作用域 <code>foo</code> 中的变量信息，那它们自然也不能被销毁... JS 引擎无法判断你什么时候还会调用闭包函数，只能一直让这些数据占用着内存。</p><blockquote><p>这种由于闭包使用过度而导致的内存占用无法释放的情况，我们称之为：内存泄露。</p></blockquote><h2 id="内存泄露" tabindex="-1"><a class="header-anchor" href="#内存泄露" aria-hidden="true">#</a> 内存泄露</h2><blockquote><p>内存泄露 是指当一块内存不再被应用程序使用的时候，由于某种原因，这块内存没有返还给操作系统或者内存池的现象。内存泄漏可能会导致应用程序卡顿或者崩溃。</p></blockquote><p>造成内存泄露的原因有很多，除了闭包以外，还有 <strong>全局变量的无意创建</strong>。开发者的本意是想将变量作为局部变量使用，然而忘记写 <code>var</code> 导致变量被泄露到全局中：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b <span class="token operator">=</span> <span class="token number">2</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token comment">// 2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>还有 <code>DOM</code> 的事件绑定，移除 <code>DOM</code> 元素前如果忘记了注销掉其中绑定的事件方法，也会造成内存泄露：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> wrapDOM <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;wrap&#39;</span><span class="token punctuation">)</span>
wrapDOM<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// some codes ...</span>

<span class="token comment">// remove wrapDOM</span>
wrapDOM<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>wrapDOM<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="内存泄露的排查手段" tabindex="-1"><a class="header-anchor" href="#内存泄露的排查手段" aria-hidden="true">#</a> 内存泄露的排查手段</h2><p>可能大家都听过臭名昭著的 “内存泄露”，然而面对茫茫祖传代码，如何找到造成内存泄露的地方，却让人无从下手。这边我们还是借助谷歌的开发者工具， <code>Chrome</code> 浏览器，<code>F12</code> 打开开发者工具，我找了阮一峰老师的 ES6 网站演示。</p><h3 id="performance" tabindex="-1"><a class="header-anchor" href="#performance" aria-hidden="true">#</a> Performance</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe308814da0ca~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe318e7c8f510~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><p>点击这个按钮启动记录，然后切换到网页进行操作，录制完成后点击 <code>stop</code> 按钮，开发者工具会从录制时刻开始记录当前应用的各项数据情况。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe328564ae5b1~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><p>选中<code>JS Heap</code>，下面展现出来的一条蓝线，就是代表了这段记录过程中，JS 堆内存信息的变化情况。</p><p>有大佬说，根据这条蓝线就可以判断是否存在内存泄漏的情况：<strong>如果这条蓝线一直成上升趋势，那基本就是内存泄漏了</strong>。其实我觉得这么讲有失偏颇，JS 堆内存占用率上升并不一定就是内存泄漏，只能说明有很多未被释放的内存而已，至于这些内存是否真的在使用，还是说确实是内存泄漏，还需要进一步排查。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe354e74c1987~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><h3 id="memory" tabindex="-1"><a class="header-anchor" href="#memory" aria-hidden="true">#</a> memory</h3><p>借助开发者工具的 Memory 选项，可以更精确地定位内存使用情况。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe400c033c14f~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe413591c09f3~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe43642d73636~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><p>当生成了第一个快照的时候，开发者工具窗口已经显示了很详细的内存占用情况。</p><p>字段解释：</p><ul><li><code>Constructor</code> — 占用内存的资源类型</li><li><code>Distance</code> — 当前对象到根的引用层级距离</li><li><code>Shallow Size</code> — 对象所占内存（不包含内部引用的其它对象所占的内存）(单位：字节)</li><li><code>Retained Size</code> — 对象所占总内存（包含内部引用的其它对象所占的内存）(单位：字节)</li></ul><p>将每项展开可以查看更详细的数据信息。</p><p>我们再次切回网页，继续操作几次，然后再次生成一个快照。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe4ad51b17a00~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe4c669e3200c~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe4e0a8a95906~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><p>这边需要特别注意这个 <code>#Delta</code> ，如果是正值，就代表新生成的内存多，释放的内存少。其中的闭包项，如果是正值，就说明存在内存泄漏。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe50b14415071~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><p>下面我们到代码里找一个内存泄漏的问题：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe528db25d0c2~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/13/16efe53c6557d2d8~tplv-t2oaga2asx-zoom-in-crop-mark:1956:0:0:0.image" alt=""></p><h2 id="内存泄露的解决方案" tabindex="-1"><a class="header-anchor" href="#内存泄露的解决方案" aria-hidden="true">#</a> 内存泄露的解决方案</h2><ol><li><p>使用严格模式，避免不经意间的全局变量泄露：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token string">&#39;use strict&#39;</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    b <span class="token operator">=</span> <span class="token number">2</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ReferenceError: b is not defined</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><p>关注 <code>DOM</code> 生命周期，在销毁阶段记得解绑相关事件：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> wrapDOM <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&#39;wrap&#39;</span><span class="token punctuation">)</span>
wrapDOM<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// some codes ...</span>

<span class="token comment">// remove wrapDOM</span>
wrapDOM<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">null</span>
wrapDOM<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>wrapDOM<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>或者可以使用事件委托的手段统一处理事件，减少由于事件绑定带来的额外内存开销：</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function-variable function">onclick</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isWrapDOM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li><li><p>避免过度使用闭包。</p></li></ol><blockquote><p>大部分的内存泄漏还是由于代码不规范导致的。代码千万条，规范第一条，代码不规范，开发两行泪。</p></blockquote><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><ol><li><code>javascript</code> 语言层面只原生支持两种作用域类型：<strong>全局作用域</strong> 和 <strong>函数作用域</strong> 。全局作用域程序运行就有，函数作用域只有定义函数的时候才有，它们之间是包含的关系。</li><li>作用域之间是可以嵌套的，我们把这种嵌套关系称为 <strong>作用域链</strong>。</li><li>可执行代码在作用域中查询变量时，只能查询 <strong>本地作用域</strong> 及 <strong>上层作用域</strong>，不能查找内部的函数作用域。JS 引擎搜索变量时，会先询问本地作用域，找到即返回，找不到再去询问上层作用域...层层往上，直到全局作用域。</li><li><code>javascript</code> 中使用的是 <strong>“词法作用域”</strong>，因此函数作用域的范围在函数定义时就已经被确定，和函数在哪执行没有关系。</li><li>有权访问另一个函数内部变量的函数，我们称为 <strong>闭包</strong>。<strong>闭包的本质是利用了作用域的机制，来达到外部作用域访问内部作用域的目的。</strong></li><li>闭包的使用场景非常广泛，然而过度使用会导致闭包内的变量所占用的内存空间无法释放，带来 <strong>内存泄露</strong> 的问题。</li><li>我们可以借助于 <code>chrome</code> 开发者工具查找代码中导致了内存泄露的代码。</li><li>避免内存泄露的几种方法：避免使用全局变量、谨慎地为<code>DOM</code> 绑定事件、避免过度使用闭包。最重要的，还是代码规范。 😃</li></ol><p>本文转自 <a href="https://juejin.cn/post/6844904165672484871" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/6844904165672484871<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>，如有侵权，请联系删除。</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 279505875@qq.cpm">ygc</span><!----><!--]--><!--]--></span></div></footer><!----></div><!--]--></div><!----><!--]--></div>
    <script type="module" src="/vuepress-study/assets/app.b87228d2.js" defer></script>
  </body>
</html>
